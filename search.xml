<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode--罗马数字转整数</title>
    <url>/Java/Roman-digital-converter/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h3 id="相关对应表："><a href="#相关对应表：" class="headerlink" title="相关对应表："></a>相关对应表：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>数值</th>
<th>字符(例外)</th>
<th>数值(例外)</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>1</td>
<td>IV</td>
<td>4</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
<td>IX</td>
<td>9</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
<td>XL</td>
<td>40</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
<td>XC</td>
<td>90</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
<td>CD</td>
<td>400</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
<td>CM</td>
<td>900</td>
</tr>
<tr>
<td>M</td>
<td>100</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul>
<li>我们将所有的组合可能列出并添加到哈希表中</li>
<li>遍历字符串，字符串的可能只有两种，一种为1个字符，一种为2个字符，两个字符优先于一个字符</li>
<li>先判断2个字符的组合在哈希表中是否存在，存在则将值取出加到结果ans中，并向后移2个字符。不存在则判断当前1个字符是否存在，存在则将值取出加到结果ans中，并向后移1个字符。</li>
<li>遍历结束返回结果 ans</li>
</ul>
<p><em>PS：</em><br>这里我们可以用containsKey来判断字符串是否存在相应的字符；<br>subtring来截取字符串的某一部分；</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"I"</span>,1);</span><br><span class="line">        map.put(<span class="string">"IV"</span>,4);</span><br><span class="line">        map.put(<span class="string">"V"</span>,5);</span><br><span class="line">        map.put(<span class="string">"IX"</span>,9);</span><br><span class="line">        map.put(<span class="string">"X"</span>,10);</span><br><span class="line">        map.put(<span class="string">"XL"</span>,40);</span><br><span class="line">        map.put(<span class="string">"L"</span>,50);</span><br><span class="line">        map.put(<span class="string">"XC"</span>,90);</span><br><span class="line">        map.put(<span class="string">"C"</span>,100);</span><br><span class="line">        map.put(<span class="string">"CD"</span>,400);</span><br><span class="line">        map.put(<span class="string">"D"</span>,500);</span><br><span class="line">        map.put(<span class="string">"CM"</span>,900);</span><br><span class="line">        map.put(<span class="string">"M"</span>,1000);</span><br><span class="line">        int ans=0;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;s.length();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+1&lt;s.length() &amp;&amp; map.containsKey(s.substring(i,i+2)))&#123;</span><br><span class="line">            ans+=map.get(s.substring(i,i+2));</span><br><span class="line">            i+=2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=map.get(s.substring(i,i+1));</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--回文数</title>
    <url>/Java/Palindrome/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个整数是否是回文数。回文数是指正序和倒序读都是一样的整数。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>可以将数字本身进行反转，如果反转后的数与原来的数想的即为回文数。这里需要注意，反转后可能会大于int.MAX导致溢出，我们可以考虑只反转数字的一半这样就避开了溢出的问题。<br>如何得知反转数的位数已经达到原始数的一半？<br>每次循环我们将原始数 / 10,反转数 * 10,当反转数大于原始数时跳出循环即处理一半数字。<br>另外负数肯定不是回文数，能被10整除的数除了0以外也都不是回文数。</p>
<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(int x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;0 || x%10==0 &amp;&amp; x!=0)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int revertedNumber=0;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;revertedNumber)&#123;</span><br><span class="line">            revertedNumber=revertedNumber*10 + x%10;</span><br><span class="line">            x/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span>  x==revertedNumber||x==revertedNumber/10;//可能为奇数或偶数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--整数反转</title>
    <url>/Java/Reverse-integere/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个32位的有符号整数,你需要将这个整数中每位上的数字进行反转。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>n位的有符号整数意思是说范围在[−2^(n−1),2^(n−1)−1]，那么32位有符号整数范围是[−2^31,2^31−1]也就是-2147483648到2147483647超出这个范围视为溢出则返回0.</p>
<ul>
<li>溢出条件有两个，一个是大于整数最大值MAX_VALUE，另一个是小于整数最小值MIN_VALUE，设当前计算结果为ans，pop为x每次除10的余数(个位数)</li>
</ul>
<ol>
<li>从ans * 10 + pop &gt; MAX_VALUE这个溢出条件来看<br> 当出现 ans &gt; MAX_VALUE / 10 且还有pop需要添加时，则一定溢出<br> 当出现 ans == MAX_VALUE / 10 且 pop &gt; 7时，则一定溢出，7是2^31 - 1的个位数。</li>
<li>从ans * 10 + pop &lt; MIN_VALUE这个溢出条件来看<br> 当出现 ans &lt; MIN_VALUE / 10 且 还有pop需要添加 时，则一定溢出<br> 当出现 ans == MIN_VALUE / 10 且 pop &lt; -8 时，则一定溢出，8是-2^31的个位数</li>
</ol>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        <span class="keyword">while</span>(x!=0)&#123;</span><br><span class="line">            int pop=x%10;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;Integer.MAX_VALUE/10||(ans==Integer.MAX_VALUE/10&amp;&amp;pop&gt;7))<span class="built_in">return</span> 0;</span><br><span class="line">            <span class="keyword">if</span>(ans&lt;Integer.MIN_VALUE/10||(ans==Integer.MIN_VALUE/10&amp;&amp;pop&lt;-8))<span class="built_in">return</span> 0;</span><br><span class="line">            ans=ans*10+pop;</span><br><span class="line">            x/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode--两数之和</title>
    <url>/Java/hello-world/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">给定 nums = [3, 5, 8,12], target = 11</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[2] = 3 + 8 = 11</span><br><span class="line">所以返回 [0,2]</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="两次循环遍历完所有的可能"><a href="#两次循环遍历完所有的可能" class="headerlink" title="两次循环遍历完所有的可能"></a>两次循环遍历完所有的可能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123; //给定的数组，目标值(两数之和)</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;nums.length;i++)&#123;	//从下标为0的数开始到小于数组长度的值为止</span><br><span class="line">            <span class="keyword">for</span>(int j=i+1;j&lt;nums.length;j++)&#123;//不能重复下标从i+1开始</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])&#123;//两数之和等于目标值target</span><br><span class="line">                    <span class="built_in">return</span> new int[]&#123;i,j&#125;;//返回数组</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(<span class="string">"No two sum solution"</span>);//手动抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
